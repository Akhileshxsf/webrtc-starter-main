<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>WebRTC Object Detection</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    .video-player { max-width: 100%; }
    .container { padding: 20px; }
    #metrics { font-size: 14px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="row mb-3 mt-3 align-items-center">
      <div id="user-name" class="col-auto fw-semibold"></div>
      <button id="generate-qr" class="btn btn-primary col-auto">Generate QR</button>
      <button id="hangup" class="btn btn-outline-danger col-auto ms-2">Hangup</button>
      <div id="qr" class="col-auto"></div>
      <div id="metrics" class="col text-end"></div>
    </div>
    <div id="videos" style="position:relative; max-width: 960px; margin:auto;">
      <video class="video-player w-100" id="remote-video" autoplay playsinline controls muted></video>
      <canvas id="overlay" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
  // Role and Identity
  const isPhone = location.search.includes('phone');
  const userName = isPhone ? 'phone' : `browser-${Math.random().toString(36).substr(2, 9)}`;
  document.querySelector('#user-name').textContent = userName;

  // UI Elements
  const remoteVideoEl = document.querySelector('#remote-video');
  const overlayCanvas = document.querySelector('#overlay');
  const metricsEl = document.querySelector('#metrics');
  const generateQrBtn = document.querySelector('#generate-qr');

  // State
  let localStream, remoteStream, peerConnection;
  let currentDetections = [], latencies = [], fpsCount = 0, lastFpsTick = performance.now();
  let sendIntervalHandle = null;

  const peerConfiguration = {
    iceServers: [{ urls: ['stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302'] }]
  };

  // Labels for SSD MobileNet
  const labels = ['person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'];

  // QR Code for Phone
  function generateQR() {
    const qrEl = document.querySelector('#qr');
    qrEl.innerHTML = '';
    const url = `${location.origin}?phone=true`;
    new QRCode(qrEl, url);
  }

  // WebRTC Core
  async function fetchUserMedia() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    } catch (e) {
      console.error('Camera access failed:', e);
      alert('Please allow camera access.');
    }
  }

  async function createPeerConnection() {
    peerConnection = new RTCPeerConnection(peerConfiguration);
    remoteStream = new MediaStream();
    remoteVideoEl.srcObject = remoteStream;

    if (localStream) {
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
    }

    peerConnection.addEventListener('icecandidate', e => {
      if (e.candidate) {
        socket.emit('sendIceCandidateToSignalingServer', { iceCandidate: e.candidate, iceUserName: userName });
      }
    });

    peerConnection.addEventListener('track', e => {
      remoteStream.addTrack(e.track);
      remoteVideoEl.srcObject = remoteStream;
    });
  }

  async function call() {
    try {
      await createPeerConnection();
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      socket.emit('newOffer', { offer });
    } catch (e) {
      console.error('Failed to create offer:', e);
    }
  }

  // Sockets (Signaling)
  const socket = io.connect(location.origin, { auth: { userName } });

  socket.on('newOffer', async (offerData) => {
    if (!isPhone) {
      try {
        await createPeerConnection();
        await peerConnection.setRemoteDescription(offerData.offer);
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit('newAnswer', { answer });
        if (remoteVideoEl.readyState >= 2) {
          startInference();
          startOverlay();
        } else {
          remoteVideoEl.addEventListener('loadedmetadata', () => {
            startInference();
            startOverlay();
          }, { once: true });
        }
      } catch (e) {
        console.error('Failed to handle offer:', e);
      }
    }
  });

  socket.on('newAnswer', async (answerData) => {
    if (isPhone) {
      try {
        await peerConnection.setRemoteDescription(answerData.answer);
      } catch (e) {
        console.error('Failed to handle answer:', e);
      }
    }
  });

  socket.on('receivedIceCandidateFromSignalingServer', async (iceCandidate) => {
    if (peerConnection) {
      try {
        await peerConnection.addIceCandidate(iceCandidate);
      } catch (e) {
        console.error('Failed to add ICE candidate:', e);
      }
    }
  });

  // Role Startup
  if (isPhone) {
    generateQrBtn.style.display = 'none';
    socket.emit('join', userName);
    fetchUserMedia().then(call);
  } else {
    socket.emit('join', userName);
    generateQrBtn.addEventListener('click', generateQR);
  }

  // Hangup
  document.querySelector('#hangup').addEventListener('click', () => {
    if (peerConnection) peerConnection.close();
    if (sendIntervalHandle) clearInterval(sendIntervalHandle);
    window.location.reload();
  });

  // Metrics
  function updateMetrics(latencyMs) {
    if (typeof latencyMs === 'number' && isFinite(latencyMs)) {
      latencies.push(latencyMs);
      if (latencies.length > 120) latencies.shift();
    }
    fpsCount++;
    const now = performance.now();
    if (now - lastFpsTick >= 1000) {
      const avgLatency = latencies.length ? (latencies.reduce((a,b)=>a+b,0) / latencies.length).toFixed(1) : 'â€“';
      metricsEl.innerHTML = `FPS: ${fpsCount} | Latency: ${avgLatency} ms | Detections: ${currentDetections.length}`;
      fpsCount = 0;
      lastFpsTick = now;
    }
  }

  // Inference with ONNX Runtime Web
  async function startInference() {
    let session;
    try {
      session = await ort.InferenceSession.create('/models/ssd_mobilenet_v1_10.onnx');
      console.log('Model loaded');
    } catch (e) {
      console.error('Failed to load model:', e);
      alert('Failed to load model. Ensure /models/ssd_mobilenet_v1_10.onnx exists.');
      return;
    }

    const capCanvas = document.createElement('canvas');
    const capCtx = capCanvas.getContext('2d');

    function syncCaptureCanvasSize() {
      if (remoteVideoEl.videoWidth && remoteVideoEl.videoHeight) {
        capCanvas.width = remoteVideoEl.videoWidth;
        capCanvas.height = remoteVideoEl.videoHeight;
      }
    }
    syncCaptureCanvasSize();

    if (sendIntervalHandle) clearInterval(sendIntervalHandle);
    sendIntervalHandle = setInterval(async () => {
      if (!remoteVideoEl.videoWidth || !remoteVideoEl.videoHeight) return;
      if (capCanvas.width !== remoteVideoEl.videoWidth || capCanvas.height !== remoteVideoEl.videoHeight) {
        syncCaptureCanvasSize();
      }

      capCtx.drawImage(remoteVideoEl, 0, 0, capCanvas.width, capCanvas.height);
      const inputCanvas = document.createElement('canvas');
      inputCanvas.width = 300;
      inputCanvas.height = 300;
      const inputCtx = inputCanvas.getContext('2d');
      inputCtx.drawImage(capCanvas, 0, 0, 300, 300);
      const imageData = inputCtx.getImageData(0, 0, 300, 300).data;

      // NHWC format [1, 300, 300, 3], uint8
      const data = new Uint8Array(300 * 300 * 3);
      let offset = 0;
      for (let y = 0; y < 300; y++) {
        for (let x = 0; x < 300; x++) {
          const pxOffset = (y * 300 + x) * 4;
          data[offset++] = imageData[pxOffset];     // R
          data[offset++] = imageData[pxOffset + 1]; // G
          data[offset++] = imageData[pxOffset + 2]; // B
        }
      }
      const tensor = new ort.Tensor('uint8', data, [1, 300, 300, 3]);

      const capture_ts = Date.now();
      let outputs;
      try {
        outputs = await session.run({ 'image_tensor:0': tensor });
      } catch (e) {
        console.error('Inference failed:', e);
        alert('Inference failed. Check the model input and outputs.');
        return;
      }
      const inference_ts = Date.now();

      // Use correct output names
      const num = outputs['num_detections:0'].data[0];
      const boxes = outputs['detection_boxes:0'].data;
      const classes = outputs['detection_classes:0'].data;
      const scores = outputs['detection_scores:0'].data;

      const detections = [];
      for (let i = 0; i < num; i++) {
        if (scores[i] > 0.5) {
          detections.push({
            label: labels[classes[i] - 1] || 'unknown',
            score: scores[i],
            ymin: boxes[i * 4],
            xmin: boxes[i * 4 + 1],
            ymax: boxes[i * 4 + 2],
            xmax: boxes[i * 4 + 3]
          });
        }
      }
      currentDetections = detections;
      updateMetrics(inference_ts - capture_ts);
    }, 200); // ~5 FPS
  }

  // Draw Bounding Boxes
  function startOverlay() {
    function drawLoop() {
      const rect = remoteVideoEl.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      overlayCanvas.style.width = rect.width + 'px';
      overlayCanvas.style.height = rect.height + 'px';
      overlayCanvas.width = Math.round(rect.width * dpr);
      overlayCanvas.height = Math.round(rect.height * dpr);
      const ctx = overlayCanvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

      const dispW = rect.width;
      const dispH = rect.height;
      ctx.lineWidth = 2;
      ctx.font = '14px sans-serif';

      currentDetections.forEach(det => {
        const x = det.xmin * dispW;
        const y = det.ymin * dispH;
        const w = (det.xmax - det.xmin) * dispW;
        const h = (det.ymax - det.ymin) * dispH;

        ctx.strokeStyle = 'lime';
        ctx.strokeRect(x, y, w, h);

        const label = `${det.label} ${(det.score * 100).toFixed(1)}%`;
        const textW = ctx.measureText(label).width;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(x, Math.max(0, y - 18), textW + 8, 18);
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 4, Math.max(14, y - 4));
      });

      requestAnimationFrame(drawLoop);
    }

    if (remoteVideoEl.readyState >= 2) {
      drawLoop();
    } else {
      remoteVideoEl.addEventListener('loadedmetadata', drawLoop, { once: true });
    }
    window.addEventListener('resize', drawLoop);
  }
  </script>
</body>
</html>